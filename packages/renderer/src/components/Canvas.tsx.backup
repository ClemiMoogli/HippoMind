/**
 * Main Canvas component using React-Konva
 */

import React, { useRef, useEffect, useState } from 'react';
import { Stage, Layer, Rect, Text, Line, Circle, Group, Image as KonvaImage } from 'react-konva';
import { useMindMapStore } from '../store/mindmap.store';
import { useUIStore } from '../store/ui.store';
import type { KonvaEventObject } from 'konva/lib/Node';
import type { MindMapNode } from '@shared';
import { generateUUID, DEFAULT_NODE_SIZE } from '@shared';
import useImage from 'use-image';

// Component to render node attachment (image or document icon)
function NodeAttachment({
  attachment,
  nodeId,
  isSelected,
  onResize
}: {
  attachment: { type: 'image' | 'document'; data: string; name: string; width?: number; height?: number; path?: string };
  nodeId: string;
  isSelected: boolean;
  onResize?: (width: number, height: number) => void;
}) {
  const [image] = useImage(attachment.type === 'image' ? attachment.data : '');

  if (attachment.type === 'image') {
    if (!image) return null;

    // Use custom dimensions if available, otherwise calculate from image
    const displayWidth = attachment.width || Math.min(160, image.width);
    const displayHeight = attachment.height || (displayWidth / image.width * image.height);

    return (
      <>
        <KonvaImage
          image={image}
          width={displayWidth}
          height={displayHeight}
          listening={false}
        />
        {/* Resize handles for selected node */}
        {isSelected && (
          <>
            {/* Bottom-right resize handle */}
            <Circle
              x={displayWidth}
              y={displayHeight}
              radius={6}
              fill="white"
              stroke="#3b82f6"
              strokeWidth={2}
              draggable
              onDragMove={(e) => {
                const newWidth = Math.max(80, e.target.x());
                const newHeight = Math.max(60, e.target.y());
                onResize?.(newWidth, newHeight);
                e.target.x(displayWidth);
                e.target.y(displayHeight);
              }}
              onMouseEnter={(e) => {
                const container = e.target.getStage()?.container();
                if (container) container.style.cursor = 'nwse-resize';
              }}
              onMouseLeave={(e) => {
                const container = e.target.getStage()?.container();
                if (container) container.style.cursor = 'default';
              }}
            />
          </>
        )}
      </>
    );
  } else {
    // Document icon
    return (
      <Group
        onClick={async () => {
          console.log('Document clicked:', attachment.name);
          try {
            // Create a temporary file from the base64 data and open it
            const { open } = await import('@tauri-apps/plugin-shell');
            const { BaseDirectory, writeFile } = await import('@tauri-apps/plugin-fs');

            // Extract base64 data (remove data URL prefix)
            const base64Data = attachment.data.split(',')[1];

            // Convert base64 to Uint8Array
            const binaryString = atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }

            // Write to temp directory with original filename
            const tempFileName = `localmind-temp-${Date.now()}-${attachment.name}`;
            await writeFile(tempFileName, bytes, { baseDir: BaseDirectory.Temp });

            // Get the temp path and open it
            const { join, tempDir } = await import('@tauri-apps/api/path');
            const tempPath = await join(await tempDir(), tempFileName);

            console.log('Opening file:', tempPath);
            await open(tempPath);
          } catch (error) {
            console.error('Error opening document:', error);
            alert(`Erreur lors de l'ouverture du document: ${error}`);
          }
        }}
        onMouseEnter={(e) => {
          const container = e.target.getStage()?.container();
          if (container) container.style.cursor = 'pointer';
        }}
        onMouseLeave={(e) => {
          const container = e.target.getStage()?.container();
          if (container) container.style.cursor = 'default';
        }}
      >
        {/* Document icon background */}
        <Rect
          width={48}
          height={56}
          fill="#f3f4f6"
          stroke="#9ca3af"
          strokeWidth={2}
          cornerRadius={4}
        />
        {/* Folded corner */}
        <Line
          points={[36, 0, 48, 12, 36, 12, 36, 0]}
          fill="#e5e7eb"
          closed
          stroke="#9ca3af"
          strokeWidth={1}
        />
        {/* Document lines */}
        <Line points={[12, 20, 36, 20]} stroke="#6b7280" strokeWidth={2} />
        <Line points={[12, 28, 36, 28]} stroke="#6b7280" strokeWidth={2} />
        <Line points={[12, 36, 28, 36]} stroke="#6b7280" strokeWidth={2} />
        {/* File name */}
        <Text
          y={60}
          width={80}
          text={attachment.name}
          fontSize={10}
          fill="#374151"
          align="center"
          wrap="none"
          ellipsis
        />
      </Group>
    );
  }
}

export function Canvas() {
  const stageRef = useRef<any>(null);
  const document = useMindMapStore((state) => state.document);
  const selectedNodeId = useMindMapStore((state) => state.selectedNodeId);
  const selectedEdge = useMindMapStore((state) => state.selectedEdge);
  const selectNode = useMindMapStore((state) => state.selectNode);
  const selectEdge = useMindMapStore((state) => state.selectEdge);
  const updateNode = useMindMapStore((state) => state.updateNode);
  const updateDocument = useMindMapStore((state) => state.updateDocument);
  const pushHistory = useMindMapStore((state) => state.pushHistory);

  const zoom = useUIStore((state) => state.zoom);
  const pan = useUIStore((state) => state.pan);
  const setZoom = useUIStore((state) => state.setZoom);
  const setPan = useUIStore((state) => state.setPan);

  const containerRef = useRef<HTMLDivElement>(null);
  const isPanningRef = useRef(false);
  const lastPosRef = useRef({ x: 0, y: 0 });
  const [editingNodeId, setEditingNodeId] = React.useState<string | null>(null);
  const [editText, setEditText] = React.useState('');
  const hasCenteredRef = useRef(false);

  // Center the view when a new document is loaded
  useEffect(() => {
    if (document && containerRef.current && !hasCenteredRef.current) {
      const rootNode = document.nodes[document.rootId];
      if (rootNode) {
        const containerWidth = containerRef.current.clientWidth;
        const containerHeight = containerRef.current.clientHeight;

        // Calculate pan to center the root node
        const centerX = containerWidth / 2 - rootNode.size.w / 2;
        const centerY = containerHeight / 2 - rootNode.size.h / 2;

        setPan({ x: centerX, y: centerY });
        hasCenteredRef.current = true;
      }
    }
  }, [document, setPan]);

  // Reset centering flag when document changes
  useEffect(() => {
    hasCenteredRef.current = false;
  }, [document?.rootId]);

  // Handle wheel zoom
  const handleWheel = (e: KonvaEventObject<WheelEvent>) => {
    e.evt.preventDefault();

    const stage = e.target.getStage();
    if (!stage) return;

    const oldScale = zoom;
    const pointer = stage.getPointerPosition();
    if (!pointer) return;

    const mousePointTo = {
      x: (pointer.x - pan.x) / oldScale,
      y: (pointer.y - pan.y) / oldScale,
    };

    const direction = e.evt.deltaY > 0 ? -1 : 1;
    const newScale = Math.max(0.1, Math.min(3, oldScale + direction * 0.1));

    setZoom(newScale);

    const newPos = {
      x: pointer.x - mousePointTo.x * newScale,
      y: pointer.y - mousePointTo.y * newScale,
    };
    setPan(newPos);
  };

  // Handle space + drag panning and Escape to cancel link creation
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.code === 'Space' && !e.repeat) {
        isPanningRef.current = true;
        container.style.cursor = 'grab';
      }

      // Cancel editing with Escape
      if (e.code === 'Escape') {
        setEditingNodeId(null);
        setEditText('');
      }
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      if (e.code === 'Space') {
        isPanningRef.current = false;
        container.style.cursor = 'default';
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  // Handle drag-and-drop for files
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleDragOver = (e: DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = 'copy';
      }
    };

    const handleDrop = async (e: DragEvent) => {
      e.preventDefault();
      e.stopPropagation();

      console.log('Drop event triggered');

      if (!e.dataTransfer?.files || e.dataTransfer.files.length === 0) {
        console.log('No files in drop');
        return;
      }

      if (!selectedNodeId || !document) {
        console.log('No node selected or no document');
        alert('Veuillez sélectionner un nœud avant de glisser-déposer un fichier');
        return;
      }

      const file = e.dataTransfer.files[0];
      console.log('File dropped:', file.name, file.type);

      const reader = new FileReader();

      reader.onload = async (event) => {
        const dataUrl = event.target?.result as string;
        const isImage = file.type.startsWith('image/');

        console.log('File loaded, isImage:', isImage);

        pushHistory();

        if (isImage) {
          // Load image to get dimensions
          const img = new Image();
          img.onload = () => {
            console.log('Image loaded, dimensions:', img.width, img.height);
            updateNode(selectedNodeId, {
              data: {
                ...document.nodes[selectedNodeId].data,
                attachment: {
                  type: 'image',
                  data: dataUrl,
                  name: file.name,
                  mimeType: file.type,
                  width: Math.min(160, img.width),
                  height: Math.min(160, img.width) / img.width * img.height,
                }
              }
            });
          };
          img.onerror = (err) => {
            console.error('Image load error:', err);
          };
          img.src = dataUrl;
        } else {
          // Document - store the data URL so it can be saved in the .mindmap file
          console.log('Adding document attachment');
          updateNode(selectedNodeId, {
            data: {
              ...document.nodes[selectedNodeId].data,
              attachment: {
                type: 'document',
                data: dataUrl,
                name: file.name,
                mimeType: file.type,
                // Note: The path won't work for opening, we'll need to save the file temporarily
                path: file.name,
              }
            }
          });
        }
      };

      reader.onerror = (err) => {
        console.error('FileReader error:', err);
      };

      reader.readAsDataURL(file);
    };

    container.addEventListener('dragover', handleDragOver);
    container.addEventListener('drop', handleDrop);

    return () => {
      container.removeEventListener('dragover', handleDragOver);
      container.removeEventListener('drop', handleDrop);
    };
  }, [selectedNodeId, document, pushHistory, updateNode]);

  const handleMouseDown = (e: KonvaEventObject<MouseEvent>) => {
    // Pan with space key, right click, or middle mouse button
    const isRightClick = e.evt.button === 2;
    const isMiddleClick = e.evt.button === 1;
    const shouldPan = isPanningRef.current || isRightClick || isMiddleClick;

    if (shouldPan) {
      e.evt.preventDefault();
      const pos = e.target.getStage()?.getPointerPosition();
      if (pos) {
        lastPosRef.current = pos;
        isPanningRef.current = true;
        if (containerRef.current) {
          containerRef.current.style.cursor = 'grabbing';
        }
      }
    }

    // Deselect node and edge if clicking on background
    if (e.target === e.target.getStage()) {
      selectNode(null);
      selectEdge(null, null);
    }
  };

  const handleMouseMove = (e: KonvaEventObject<MouseEvent>) => {
    if (isPanningRef.current) {
      const pos = e.target.getStage()?.getPointerPosition();
      if (pos) {
        const dx = pos.x - lastPosRef.current.x;
        const dy = pos.y - lastPosRef.current.y;
        setPan({ x: pan.x + dx, y: pan.y + dy });
        lastPosRef.current = pos;
      }
    }
  };

  const handleMouseUp = (e: KonvaEventObject<MouseEvent>) => {
    if (isPanningRef.current) {
      isPanningRef.current = false;
      if (containerRef.current) {
        containerRef.current.style.cursor = 'default';
      }
    }
  };

  // Handle double-click to create new node
  const handleDblClick = (e: KonvaEventObject<MouseEvent>) => {
    // Only create node if double-clicking on empty space
    if (e.target !== e.target.getStage()) return;

    const stage = e.target.getStage();
    if (!stage || !document) return;

    const pos = stage.getPointerPosition();
    if (!pos) return;

    // Save current state before making changes
    pushHistory();

    // Convert screen coordinates to canvas coordinates
    const x = (pos.x - pan.x) / zoom;
    const y = (pos.y - pan.y) / zoom;

    // Create a new node at this position
    const newId = generateUUID();
    const defaultText = 'Nouveau nœud';
    const newNode: MindMapNode = {
      id: newId,
      text: defaultText,
      pos: { x, y },
      size: calculateTextSize(defaultText),
      style: {},
      data: { notes: '', tags: [] },
      children: [],
    };

    const updatedNodes = { ...document.nodes };
    updatedNodes[newId] = newNode;

    // Don't add to any parent - standalone node for now
    updateDocument({ nodes: updatedNodes });
    selectNode(newId);
  };

  // Create child node with automatic positioning for multiple children
  const handleCreateChild = (parentId: string) => {
    if (!document) return;

    const parent = document.nodes[parentId];
    if (!parent) return;

    // Save current state before making changes
    pushHistory();

    const newId = generateUUID();

    // Calculate vertical position based on number of existing children
    const siblingCount = parent.children.length;
    const verticalSpacing = 80; // Space between siblings
    const yOffset = siblingCount * verticalSpacing;

    const defaultText = 'Nouveau nœud';
    const newNode: MindMapNode = {
      id: newId,
      text: defaultText,
      pos: {
        x: parent.pos.x + 220,
        y: parent.pos.y + yOffset
      },
      size: calculateTextSize(defaultText),
      style: {},
      data: { notes: '', tags: [] },
      children: [],
    };

    const updatedNodes = { ...document.nodes };
    updatedNodes[newId] = newNode;
    updatedNodes[parentId] = {
      ...parent,
      children: [...parent.children, newId],
    };

    updateDocument({ nodes: updatedNodes });
    selectNode(newId);
  };

  // Handle node click
  const handleNodeClick = (e: KonvaEventObject<MouseEvent>, nodeId: string) => {
    selectNode(nodeId);
  };

  // Handle double-click on node to edit
  const handleNodeDblClick = (nodeId: string) => {
    const node = document?.nodes[nodeId];
    if (!node) return;

    // Save current state before editing
    pushHistory();

    setEditingNodeId(nodeId);
    setEditText(node.text);
  };

  // Calculate text size for auto-sizing nodes
  const calculateTextSize = (
    text: string,
    fontSize: number = 16,
    fontWeight: string = 'normal',
    fontStyle: string = 'normal'
  ): { w: number; h: number } => {
    // Create a temporary canvas to measure text
    const canvas = window.document.createElement('canvas');
    const context = canvas.getContext('2d');
    if (!context) return { w: 180, h: 60 }; // Default size

    context.font = `${fontStyle} ${fontWeight} ${fontSize}px system-ui, -apple-system, sans-serif`;

    // Split text into words and measure
    const words = text.split(' ');
    const maxWidth = 300; // Maximum width before wrapping
    const padding = 24; // Horizontal padding (12px each side)
    const lineHeight = fontSize * 1.5;

    let lines: string[] = [];
    let currentLine = '';

    words.forEach(word => {
      const testLine = currentLine ? `${currentLine} ${word}` : word;
      const metrics = context.measureText(testLine);

      if (metrics.width > maxWidth - padding && currentLine) {
        lines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    });

    if (currentLine) {
      lines.push(currentLine);
    }

    // Calculate final size
    const longestLineWidth = Math.max(...lines.map(line => context.measureText(line).width));
    const width = Math.max(120, Math.min(maxWidth, longestLineWidth + padding));
    const height = Math.max(60, lines.length * lineHeight + padding);

    return { w: Math.round(width), h: Math.round(height) };
  };

  // Save edited text and resize node
  const handleSaveEdit = () => {
    if (editingNodeId && editText.trim()) {
      const node = document?.nodes[editingNodeId];
      if (node) {
        const fontSize = node.style.fontSize ?? 16;
        const fontWeight = node.style.fontWeight ?? 'normal';
        const fontStyle = node.style.fontStyle ?? 'normal';
        const newSize = calculateTextSize(editText.trim(), fontSize, fontWeight, fontStyle);
        updateNode(editingNodeId, {
          text: editText.trim(),
          size: newSize
        });
      }
    }
    setEditingNodeId(null);
    setEditText('');
  };

  if (!document) {
    return (
      <div className="canvas-container flex items-center justify-center">
        <p className="text-gray-500">Aucune carte ouverte</p>
      </div>
    );
  }

  const nodes = Object.values(document.nodes);
  const theme = document.theme;

  // Calculate smooth connection points based on angle between node centers
  const getConnectionPoints = (
    parent: MindMapNode,
    child: MindMapNode
  ): { startX: number; startY: number; endX: number; endY: number } => {
    const parentCenterX = parent.pos.x + parent.size.w / 2;
    const parentCenterY = parent.pos.y + parent.size.h / 2;
    const childCenterX = child.pos.x + child.size.w / 2;
    const childCenterY = child.pos.y + child.size.h / 2;

    // Calculate angle from parent to child
    const dx = childCenterX - parentCenterX;
    const dy = childCenterY - parentCenterY;
    const angle = Math.atan2(dy, dx);

    // Function to get intersection point with rectangle edge based on angle
    const getEdgePoint = (
      centerX: number,
      centerY: number,
      width: number,
      height: number,
      angle: number
    ): { x: number; y: number } => {
      const halfW = width / 2;
      const halfH = height / 2;

      // Normalize angle to 0-2π
      let normalizedAngle = angle;
      while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
      while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;

      const cos = Math.cos(normalizedAngle);
      const sin = Math.sin(normalizedAngle);

      // Calculate intersection with all four edges and pick the closest
      let x: number, y: number;

      // Calculate the parametric t for intersection with each edge
      const tRight = cos > 0 ? halfW / cos : Infinity;
      const tLeft = cos < 0 ? -halfW / cos : Infinity;
      const tBottom = sin > 0 ? halfH / sin : Infinity;
      const tTop = sin < 0 ? -halfH / sin : Infinity;

      // Find minimum positive t (closest intersection)
      const t = Math.min(tRight, tLeft, tBottom, tTop);

      x = centerX + t * cos;
      y = centerY + t * sin;

      // Final safety clamp
      x = Math.max(centerX - halfW, Math.min(centerX + halfW, x));
      y = Math.max(centerY - halfH, Math.min(centerY + halfH, y));

      return { x, y };
    };

    // Get start point on parent (facing child)
    const startPoint = getEdgePoint(
      parentCenterX,
      parentCenterY,
      parent.size.w,
      parent.size.h,
      angle
    );

    // Get end point on child (facing parent - opposite angle)
    const endPoint = getEdgePoint(
      childCenterX,
      childCenterY,
      child.size.w,
      child.size.h,
      angle + Math.PI // Opposite direction
    );

    return {
      startX: startPoint.x,
      startY: startPoint.y,
      endX: endPoint.x,
      endY: endPoint.y,
    };
  };


  // Generate edge path based on style
  const generateEdgePath = (
    startX: number,
    startY: number,
    endX: number,
    endY: number,
    style: string
  ): number[] => {
    switch (style) {
      case 'straight':
        return [startX, startY, endX, endY];

      case 'smooth':
        // Smooth curve with two control points
        const dx = endX - startX;
        const dy = endY - startY;
        const offsetX = Math.abs(dx) * 0.5;
        const cp1X = startX + offsetX;
        const cp1Y = startY;
        const cp2X = endX - offsetX;
        const cp2Y = endY;
        return [startX, startY, cp1X, cp1Y, cp2X, cp2Y, endX, endY];

      default:
        return [startX, startY, endX, endY];
    }
  };

  // Render edges with smart connections
  const edges: JSX.Element[] = [];
  const defaultEdgeStyle = theme.edge?.style || 'smooth';
  const defaultEdgeWidth = theme.edge?.width || 2;
  const defaultEdgeColor = theme.edge?.color || theme.node.border;

  nodes.forEach((node) => {
    node.children.forEach((childId) => {
      const child = document.nodes[childId];
      if (child) {
        const { startX, startY, endX, endY } = getConnectionPoints(node, child);

        // Get edge style from document.edges using the key "parentId->childId"
        const edgeKey = `${node.id}->${childId}`;
        const edgeStyleData = document.edges?.[edgeKey];

        // Use individual edge style if defined, otherwise use theme default
        const edgeStyle = edgeStyleData?.style || defaultEdgeStyle;
        const edgeWidth = edgeStyleData?.width || defaultEdgeWidth;
        const edgeColor = edgeStyleData?.color || defaultEdgeColor;

        const points = generateEdgePath(startX, startY, endX, endY, edgeStyle);

        // Check if this edge is selected
        const isEdgeSelected =
          selectedEdge?.parentId === node.id && selectedEdge?.childId === childId;

        edges.push(
          <Line
            key={`edge-${node.id}-${childId}`}
            points={points}
            stroke={isEdgeSelected ? '#3b82f6' : edgeColor}
            strokeWidth={isEdgeSelected ? edgeWidth + 2 : edgeWidth}
            lineCap="round"
            lineJoin="round"
            tension={edgeStyle === 'smooth' ? 0.4 : 0}
            bezier={edgeStyle === 'smooth'}
            hitStrokeWidth={20}
            onClick={(e) => {
              e.cancelBubble = true;
              selectEdge(node.id, childId);
            }}
            onTap={(e) => {
              e.cancelBubble = true;
              selectEdge(node.id, childId);
            }}
            onMouseEnter={(e) => {
              const container = e.target.getStage()?.container();
              if (container) container.style.cursor = 'pointer';
            }}
            onMouseLeave={(e) => {
              const container = e.target.getStage()?.container();
              if (container) container.style.cursor = 'default';
            }}
          />
        );
      }
    });
  });


  return (
    <div ref={containerRef} className="canvas-container relative">
      {/* Text editing input */}
      {editingNodeId && document?.nodes[editingNodeId] && (
        <div
          className="absolute z-50"
          style={{
            left: `${document.nodes[editingNodeId].pos.x * zoom + pan.x}px`,
            top: `${document.nodes[editingNodeId].pos.y * zoom + pan.y}px`,
            width: `${document.nodes[editingNodeId].size.w * zoom}px`,
            height: `${document.nodes[editingNodeId].size.h * zoom}px`,
          }}
        >
          <input
            type="text"
            value={editText}
            onChange={(e) => setEditText(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') {
                e.preventDefault();
                handleSaveEdit();
              } else if (e.key === 'Escape') {
                e.preventDefault();
                setEditingNodeId(null);
                setEditText('');
              }
              // Allow normal text editing keys to propagate
              e.stopPropagation();
            }}
            onBlur={handleSaveEdit}
            onClick={(e) => e.stopPropagation()}
            onDoubleClick={(e) => e.stopPropagation()}
            autoFocus
            className="w-full h-full px-3 text-center border-2 border-blue-500 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-300"
            style={{
              fontSize: `${(document.nodes[editingNodeId].style.fontSize ?? 16) * zoom}px`,
              fontWeight: document.nodes[editingNodeId].style.fontWeight ?? 'normal',
              fontStyle: document.nodes[editingNodeId].style.fontStyle ?? 'normal',
              backgroundColor: document.nodes[editingNodeId].style.bg ?? document.theme.node.bg,
              color: document.nodes[editingNodeId].style.fg ?? document.theme.node.fg,
              borderColor: '#3b82f6',
              borderRadius: document.theme.node.shape === 'pill' ? `${document.nodes[editingNodeId].size.h / 2}px` : '8px',
            }}
          />
        </div>
      )}

      <Stage
        ref={stageRef}
        width={containerRef.current?.clientWidth ?? 800}
        height={containerRef.current?.clientHeight ?? 600}
        scaleX={zoom}
        scaleY={zoom}
        x={pan.x}
        y={pan.y}
        onWheel={handleWheel}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onDblClick={handleDblClick}
        onContextMenu={(e) => e.evt.preventDefault()}
        draggable={false}
      >
        <Layer>
          {/* Edges */}
          {edges}

          {/* Nodes */}
          {nodes.map((node) => {
            const isSelected = node.id === selectedNodeId;
            const bgColor = node.style.bg ?? theme.node.bg;
            const fgColor = node.style.fg ?? theme.node.fg;
            const borderColor = node.style.border ?? theme.node.border;
            const fontSize = node.style.fontSize ?? 16;
            const fontWeight = node.style.fontWeight ?? 'normal';
            const fontStyle = node.style.fontStyle ?? 'normal';

            return (
              <Group key={node.id}>
                {/* Main node */}
                <Group
                  x={node.pos.x}
                  y={node.pos.y}
                  draggable
                  onDragStart={() => {
                    // Save current state before starting drag
                    pushHistory();
                  }}
                  onDragMove={(e) => {
                    // Update node position in real-time during drag for smooth edge updates
                    updateNode(node.id, {
                      pos: { x: e.target.x(), y: e.target.y() },
                    });
                  }}
                  onDragEnd={(e) => {
                    // Final position update (already done in onDragMove)
                  }}
                  onClick={(e: any) => handleNodeClick(e, node.id)}
                  onTap={(e: any) => handleNodeClick(e, node.id)}
                  onDblClick={() => handleNodeDblClick(node.id)}
                  onDblTap={() => handleNodeDblClick(node.id)}
                >
                  <Rect
                    width={node.size.w}
                    height={node.size.h}
                    fill={bgColor}
                    stroke={isSelected ? '#3b82f6' : borderColor}
                    strokeWidth={isSelected ? 3 : 2}
                    cornerRadius={theme.node.shape === 'pill' ? node.size.h / 2 : 8}
                    shadowColor="rgba(0,0,0,0.1)"
                    shadowBlur={4}
                    shadowOffsetY={2}
                  />

                  {/* Render attachment (image or document) if present */}
                  {node.data.attachment && (
                    <Group
                      x={(node.size.w - (node.data.attachment.width || 160)) / 2}
                      y={node.size.h + 8}
                    >
                      <NodeAttachment
                        attachment={node.data.attachment}
                        nodeId={node.id}
                        isSelected={isSelected}
                        onResize={(width, height) => {
                          updateNode(node.id, {
                            data: {
                              ...node.data,
                              attachment: {
                                ...node.data.attachment!,
                                width,
                                height,
                              }
                            }
                          });
                        }}
                      />
                    </Group>
                  )}

                  <Text
                    width={node.size.w}
                    height={node.size.h}
                    text={node.text}
                    fontSize={fontSize}
                    fontFamily="system-ui, -apple-system, sans-serif"
                    fontStyle={fontWeight === 'bold' && fontStyle === 'italic' ? 'bold italic' : fontWeight === 'bold' ? 'bold' : fontStyle}
                    fill={fgColor}
                    align="center"
                    verticalAlign="middle"
                    padding={12}
                    listening={false}
                  />
                </Group>

                {/* Action buttons and resize handles - only show for selected node */}
                {isSelected && (
                  <>
                    {/* Add child button (right side) */}
                    <Group
                      x={node.pos.x + node.size.w + 8}
                      y={node.pos.y + node.size.h / 2 - 12}
                      onClick={(e) => {
                        e.cancelBubble = true;
                        handleCreateChild(node.id);
                      }}
                    >
                      <Circle radius={12} fill="#3b82f6" />
                      <Text
                        x={-6}
                        y={-8}
                        text="+"
                        fontSize={18}
                        fill="white"
                        fontStyle="bold"
                        listening={false}
                      />
                    </Group>

                    {/* Resize handles (8 corners and sides) */}
                    {/* Top-left corner */}
                    <Circle
                      x={node.pos.x}
                      y={node.pos.y}
                      radius={6}
                      fill="white"
                      stroke="#3b82f6"
                      strokeWidth={2}
                      draggable
                      onDragStart={() => pushHistory()}
                      onDragMove={(e) => {
                        const deltaX = e.target.x() - node.pos.x;
                        const deltaY = e.target.y() - node.pos.y;
                        updateNode(node.id, {
                          pos: { x: node.pos.x + deltaX, y: node.pos.y + deltaY },
                          size: { w: Math.max(80, node.size.w - deltaX), h: Math.max(40, node.size.h - deltaY) },
                        });
                        e.target.x(node.pos.x);
                        e.target.y(node.pos.y);
                      }}
                      onMouseEnter={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'nwse-resize';
                      }}
                      onMouseLeave={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'default';
                      }}
                    />

                    {/* Top-right corner */}
                    <Circle
                      x={node.pos.x + node.size.w}
                      y={node.pos.y}
                      radius={6}
                      fill="white"
                      stroke="#3b82f6"
                      strokeWidth={2}
                      draggable
                      onDragStart={() => pushHistory()}
                      onDragMove={(e) => {
                        const deltaX = e.target.x() - (node.pos.x + node.size.w);
                        const deltaY = e.target.y() - node.pos.y;
                        updateNode(node.id, {
                          pos: { x: node.pos.x, y: node.pos.y + deltaY },
                          size: { w: Math.max(80, node.size.w + deltaX), h: Math.max(40, node.size.h - deltaY) },
                        });
                        e.target.x(node.pos.x + node.size.w);
                        e.target.y(node.pos.y);
                      }}
                      onMouseEnter={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'nesw-resize';
                      }}
                      onMouseLeave={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'default';
                      }}
                    />

                    {/* Bottom-left corner */}
                    <Circle
                      x={node.pos.x}
                      y={node.pos.y + node.size.h}
                      radius={6}
                      fill="white"
                      stroke="#3b82f6"
                      strokeWidth={2}
                      draggable
                      onDragStart={() => pushHistory()}
                      onDragMove={(e) => {
                        const deltaX = e.target.x() - node.pos.x;
                        const deltaY = e.target.y() - (node.pos.y + node.size.h);
                        updateNode(node.id, {
                          pos: { x: node.pos.x + deltaX, y: node.pos.y },
                          size: { w: Math.max(80, node.size.w - deltaX), h: Math.max(40, node.size.h + deltaY) },
                        });
                        e.target.x(node.pos.x);
                        e.target.y(node.pos.y + node.size.h);
                      }}
                      onMouseEnter={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'nesw-resize';
                      }}
                      onMouseLeave={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'default';
                      }}
                    />

                    {/* Bottom-right corner */}
                    <Circle
                      x={node.pos.x + node.size.w}
                      y={node.pos.y + node.size.h}
                      radius={6}
                      fill="white"
                      stroke="#3b82f6"
                      strokeWidth={2}
                      draggable
                      onDragStart={() => pushHistory()}
                      onDragMove={(e) => {
                        const deltaX = e.target.x() - (node.pos.x + node.size.w);
                        const deltaY = e.target.y() - (node.pos.y + node.size.h);
                        updateNode(node.id, {
                          size: { w: Math.max(80, node.size.w + deltaX), h: Math.max(40, node.size.h + deltaY) },
                        });
                        e.target.x(node.pos.x + node.size.w);
                        e.target.y(node.pos.y + node.size.h);
                      }}
                      onMouseEnter={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'nwse-resize';
                      }}
                      onMouseLeave={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'default';
                      }}
                    />

                    {/* Right side handle */}
                    <Circle
                      x={node.pos.x + node.size.w}
                      y={node.pos.y + node.size.h / 2}
                      radius={6}
                      fill="white"
                      stroke="#3b82f6"
                      strokeWidth={2}
                      draggable
                      onDragStart={() => pushHistory()}
                      onDragMove={(e) => {
                        const deltaX = e.target.x() - (node.pos.x + node.size.w);
                        updateNode(node.id, {
                          size: { w: Math.max(80, node.size.w + deltaX), h: node.size.h },
                        });
                        e.target.x(node.pos.x + node.size.w);
                        e.target.y(node.pos.y + node.size.h / 2);
                      }}
                      onMouseEnter={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'ew-resize';
                      }}
                      onMouseLeave={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'default';
                      }}
                    />

                    {/* Left side handle */}
                    <Circle
                      x={node.pos.x}
                      y={node.pos.y + node.size.h / 2}
                      radius={6}
                      fill="white"
                      stroke="#3b82f6"
                      strokeWidth={2}
                      draggable
                      onDragStart={() => pushHistory()}
                      onDragMove={(e) => {
                        const deltaX = e.target.x() - node.pos.x;
                        updateNode(node.id, {
                          pos: { x: node.pos.x + deltaX, y: node.pos.y },
                          size: { w: Math.max(80, node.size.w - deltaX), h: node.size.h },
                        });
                        e.target.x(node.pos.x);
                        e.target.y(node.pos.y + node.size.h / 2);
                      }}
                      onMouseEnter={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'ew-resize';
                      }}
                      onMouseLeave={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'default';
                      }}
                    />

                    {/* Top side handle */}
                    <Circle
                      x={node.pos.x + node.size.w / 2}
                      y={node.pos.y}
                      radius={6}
                      fill="white"
                      stroke="#3b82f6"
                      strokeWidth={2}
                      draggable
                      onDragStart={() => pushHistory()}
                      onDragMove={(e) => {
                        const deltaY = e.target.y() - node.pos.y;
                        updateNode(node.id, {
                          pos: { x: node.pos.x, y: node.pos.y + deltaY },
                          size: { w: node.size.w, h: Math.max(40, node.size.h - deltaY) },
                        });
                        e.target.x(node.pos.x + node.size.w / 2);
                        e.target.y(node.pos.y);
                      }}
                      onMouseEnter={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'ns-resize';
                      }}
                      onMouseLeave={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'default';
                      }}
                    />

                    {/* Bottom side handle */}
                    <Circle
                      x={node.pos.x + node.size.w / 2}
                      y={node.pos.y + node.size.h}
                      radius={6}
                      fill="white"
                      stroke="#3b82f6"
                      strokeWidth={2}
                      draggable
                      onDragStart={() => pushHistory()}
                      onDragMove={(e) => {
                        const deltaY = e.target.y() - (node.pos.y + node.size.h);
                        updateNode(node.id, {
                          size: { w: node.size.w, h: Math.max(40, node.size.h + deltaY) },
                        });
                        e.target.x(node.pos.x + node.size.w / 2);
                        e.target.y(node.pos.y + node.size.h);
                      }}
                      onMouseEnter={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'ns-resize';
                      }}
                      onMouseLeave={(e) => {
                        const container = e.target.getStage()?.container();
                        if (container) container.style.cursor = 'default';
                      }}
                    />
                  </>
                )}
              </Group>
            );
          })}
        </Layer>
      </Stage>
    </div>
  );
}
